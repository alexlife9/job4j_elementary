package ru.job4j.array;

/*import static java.lang.System.arraycopy;

public class Merge {

    public static int[] merge(int[] left, int[] right) {
        int i = 0, j = 0, k = 0;

        while (i < left.length && j < right.length) {
            a3[k++] = left[i] < right[j] ? left[i++] : right[j++];
        }
        if (i < left.length) {
            arraycopy(left, i, a3, k, left.length - i);
        } else if (j < right.length) {
            arraycopy(right, j, a3, k, right.length - j);
        }
        return a3;
    }
}*/
// не доделан этот способ

public class Merge {

    public static int[] merge(int[] left, int[] right) {
        int[] rsl = new int[left.length + right.length];
        int i = 0, j = 0;
        for (int k = 0; k < rsl.length; k++) {
            if (i > left.length - 1) {
                int a = right[j];
                rsl[k] = a;
                j++;
            } else if (j > right.length - 1) {
                int a = left[i];
                rsl[k] = a;
                i++;
            } else if (left[i] < right[j]) {
                int a = left[i];
                rsl[k] = a;
                i++;
            } else {
                int b = right[j];
                rsl[k] = b;
                j++;
            }
        }
        return rsl;
    }
}

//Сортировка слиянием — очень эффективный алгоритм внешней сортировки. Разумеется, как любой алгоритм сложности O(n*ln(n)),
//он будет эффективен и для сортировки массивов… Но зачем, когда для массивов есть множество более эффективных алгоритмов внутренней сортировки?
//
//Надо понимать, что для разных данных надо использовать разные алгоритмы.
//Для массива из 10 чисел простейший, но имеющий минимальные накладные расходы, алгоритм сложности O(n^2) будет эффективнее,
//чем быстрый алгоритм сложности O(n*ln(n)): чем меньше объём данных, тем заметнее накладные расходы, требуемые для быстрых алгоритмов.
//
//Для массива из 10 тысяч строк уже понадобится алгоритм сложности O(n*ln(n)). Но опять же,
//выбор алгоритма зависит от сортируемых данных и наличия ресурсов.
//Например, пирамидальная сортировка в среднем медленнее, чем быстрая, но если требуется минимизировать затраты памяти (например, в микроконтроллере),
//то эффективнее будет именно пирамидальная. А уж сортировка слиянием в задачах, требующих минимизации памяти, вообще не рассматривается.
//
//А для линейного однонаправленного списка, или для файла, размер которого превышает объём RAM (вполне себе типичная ситуация для баз данных),
//будет использован один из алгоритмов внешней сортировки. В том числе и сортировка слиянием.